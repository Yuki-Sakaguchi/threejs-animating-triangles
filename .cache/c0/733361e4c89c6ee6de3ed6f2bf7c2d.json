{"id":"node_modules/three-extend-material/src/ExtendMaterial.ts","dependencies":[{"name":"/Users/sakaguchiyuuki/work/github/threejs-animating-triangles/package.json","includedInParent":true,"mtime":1665836573743},{"name":"/Users/sakaguchiyuuki/work/github/threejs-animating-triangles/node_modules/three-extend-material/package.json","includedInParent":true,"mtime":1665836692710},{"name":"three","loc":{"line":42,"column":33},"parent":"/Users/sakaguchiyuuki/work/github/threejs-animating-triangles/node_modules/three-extend-material/src/ExtendMaterial.ts","resolved":"/Users/sakaguchiyuuki/work/github/threejs-animating-triangles/node_modules/three-extend-material/node_modules/three/build/three.module.js"}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mapShader = exports.cloneUniform = exports.cloneUniforms = exports.extendMaterial = exports.patchShader = exports.CustomMaterial = void 0;\nvar THREE = __importStar(require(\"three\"));\n// Author: Fyrestar https://mevedia.com (https://github.com/Fyrestar/THREE.extendMaterial)\nvar ShaderChunk = THREE.ShaderChunk, UniformsLib = THREE.UniformsLib, Vector2 = THREE.Vector2, Color = THREE.Color, EventDispatcher = THREE.EventDispatcher, TangentSpaceNormalMap = THREE.TangentSpaceNormalMap, MultiplyOperation = THREE.MultiplyOperation, Material = THREE.Material, ShaderMaterial = THREE.ShaderMaterial, RawShaderMaterial = THREE.RawShaderMaterial;\n// Utility functions\nfunction isShaderMaterial(target) {\n    return target && target.isShaderMaterial;\n}\nfunction isDepthMaterial(target) {\n    return ((target && target.isMeshDepthMaterial) ||\n        target === THREE.MeshDepthMaterial);\n}\n// Fix missing pairs\nvar UniformsLibExtendable = UniformsLib;\nUniformsLibExtendable.clearcoatnormalmap = {\n    clearcoatNormalScale: { value: new Vector2(1, 1) },\n};\n// Patch materials\nvar Materials = [\n    'MeshDistanceMaterial',\n    'MeshMatcapMaterial',\n    'ShadowMaterial',\n    'SpriteMaterial',\n    'RawShaderMaterial',\n    'ShaderMaterial',\n    'PointsMaterial',\n    'MeshPhysicalMaterial',\n    'MeshStandardMaterial',\n    'MeshPhongMaterial',\n    'MeshToonMaterial',\n    'MeshNormalMaterial',\n    'MeshLambertMaterial',\n    'MeshDepthMaterial',\n    'MeshBasicMaterial',\n    'LineDashedMaterial',\n    'LineBasicMaterial',\n    'Material',\n    'MeshFaceMaterial',\n    'MultiMaterial',\n    'PointCloudMaterial',\n    'ParticleBasicMaterial',\n    'ParticleSystemMaterial',\n];\nfor (var _i = 0, Materials_1 = Materials; _i < Materials_1.length; _i++) {\n    var name = Materials_1[_i];\n    if (THREE[name] !== undefined) {\n        var prototype = THREE[name].prototype;\n        // Type on prototype needed to identify when minified\n        prototype.type = name;\n        prototype.customDepthMaterial = null;\n        prototype.customDistanceMaterial = null;\n        prototype.templates = [];\n    }\n}\n// New material methods\nvar _clone = ShaderMaterial.prototype.clone;\nfunction clone() {\n    var clone = _clone.call(this);\n    clone.templates = this.templates;\n    return clone;\n}\nfunction link(source) {\n    if (source && source.uniforms) {\n        for (var name in source.uniforms) {\n            if (source.uniforms[name].linked)\n                this.uniforms[name] = source.uniforms[name];\n        }\n    }\n    return this;\n}\nfunction copy(source) {\n    Material.prototype.copy.call(this, source);\n    for (var _i = 0, mapList_1 = mapList; _i < mapList_1.length; _i++) {\n        var name = mapList_1[_i];\n        if (source[name])\n            this[name] = source[name];\n    }\n    for (var _a = 0, localsList_1 = localsList; _a < localsList_1.length; _a++) {\n        var name = localsList_1[_a];\n        if (source[name])\n            this[name] = source[name];\n    }\n    this.fragmentShader = source.fragmentShader;\n    this.vertexShader = source.vertexShader;\n    this.uniforms = cloneUniforms(source.uniforms);\n    this.defines = Object.assign({}, source.defines);\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.lights = source.lights;\n    this.clipping = source.clipping;\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n    this.extensions = source.extensions;\n    if (source.customDepthMaterial)\n        this.customDepthMaterial = source.customDepthMaterial.clone().link(this);\n    if (source.customDistanceMaterial)\n        this.customDistanceMaterial = source.customDistanceMaterial\n            .clone()\n            .link(this);\n    return this;\n}\nfunction uniform(name) {\n    if (this.uniforms[name] === undefined)\n        this.uniforms[name] = { value: null };\n    return this.uniforms[name];\n}\nfunction extend(source, object) {\n    object = object || {};\n    // Extend from class or shader material\n    var uniforms = {}, vertexShader = '', fragmentShader = '';\n    // Inherit from previous material templates chain\n    var base = object.template || object.extends;\n    var MaterialClass = object.class ||\n        (source.isMaterial && source.constructor ? source.constructor : null) ||\n        CustomMaterial;\n    // New shader material\n    var material = new MaterialClass();\n    var properties = (object.material = object.material || {});\n    var defines = Object.assign({}, properties.defines);\n    // Template chain\n    material.templates = [object];\n    if (source.templates instanceof Array)\n        material.templates = source.templates.concat(material.templates);\n    var name;\n    if (source instanceof Function) {\n        // Source is a constructor\n        name = source.prototype.type;\n        var mapping = mappings[name];\n        if (mapping === undefined) {\n            console.error('THREE.extendMaterial: no mapping for material class \"%s\" found', name);\n            return material;\n        }\n        properties.lights =\n            properties.lights === undefined ? true : properties.lights;\n        uniforms = mapUniforms(mapping.name, uniforms, object); // Use only declared/necessary uniforms or all\n        vertexShader = ShaderChunk[mapping.id + '_vert'];\n        fragmentShader = ShaderChunk[mapping.id + '_frag'];\n    }\n    else if (isShaderMaterial(source)) {\n        // Source is a ShaderMaterial\n        name = source.type;\n        uniforms = cloneUniforms(source.uniforms, uniforms); // Use uniforms of previous material\n        vertexShader = source.vertexShader;\n        fragmentShader = source.fragmentShader;\n        material.copy(source, false);\n        if (source.defines)\n            Object.assign(defines, source.defines);\n    }\n    else {\n        // Source is a material instance\n        name = source.type;\n        var mapping = mappings[name];\n        if (mapping === undefined) {\n            console.error('THREE.extendMaterial: no mapping for material class \"%s\" found', name);\n            return material;\n        }\n        properties.lights =\n            properties.lights === undefined ? true : properties.lights;\n        uniforms = mapUniforms(mapping.name, uniforms, object);\n        vertexShader = ShaderChunk[mapping.id + '_vert'];\n        fragmentShader = ShaderChunk[mapping.id + '_frag'];\n        // Built-in properties to uniforms ( if explicit not disabled, those being null will be skipped )\n        var defaults = THREE.ShaderLib[mapping.name].uniforms;\n        for (var name_1 in defaults)\n            if (uniforms[name_1] === undefined &&\n                source[name_1] !== undefined &&\n                (source[name_1] !== null || object.explicit === false)) {\n                uniforms[name_1] = uniforms[name_1] || { value: null };\n                uniforms[name_1].value = source[name_1];\n            }\n    }\n    // ShaderMaterial in disguise ( currently not required )\n    //if ( material.isCustomMaterial )\n    //\tmaterial[ 'is' + name ] = true;\n    // Override constants\n    if (object.defines)\n        Object.assign(defines, object.defines);\n    // A shared header ( varyings, uniforms, functions etc )\n    var header = (object.header || '') + '\\n';\n    // Insert or replace lines (@ to replace)\n    if (object.vertex !== undefined)\n        vertexShader = applyPatches(vertexShader, object.vertex);\n    if (object.fragment !== undefined)\n        fragmentShader = applyPatches(fragmentShader, object.fragment);\n    properties.defines = defines;\n    properties.uniforms = uniforms;\n    properties.vertexShader =\n        header + (object.vertexHeader || '') + '\\n' + vertexShader;\n    properties.fragmentShader =\n        header + (object.fragmentHeader || '') + '\\n' + fragmentShader;\n    if (object.vertexEnd)\n        properties.vertexShader = properties.vertexShader.replace(/\\}(?=[^.]*$)/g, object.vertexEnd + '\\n}');\n    if (object.fragmentEnd)\n        properties.fragmentShader = properties.fragmentShader.replace(/\\}(?=[^.]*$)/g, object.fragmentEnd + '\\n}');\n    // Uniforms override\n    if (object.override) {\n        for (var name_2 in object.override) {\n            var src = object.override[name_2];\n            var dst = (uniforms[name_2] = uniforms[name_2] || { value: null });\n            for (var k in src)\n                dst[k] = src[k];\n            // Expose mixed uniforms to template if not exposed yet ( material before might have been built-in )\n            if (dst.mixed) {\n                if (!object.uniforms)\n                    object.uniforms = {};\n                object.uniforms[name_2] = dst;\n            }\n        }\n    }\n    // Apply base templates, uniforms that are required in a template must be flagged as mixed to get inherited\n    if (base && base.templates && base.templates.length) {\n        object.class = object.class || base.class;\n        for (var _i = 0, _a = base.templates; _i < _a.length; _i++) {\n            var template = _a[_i];\n            patchShader(properties, template, mixUniforms, defines);\n        }\n        // Linked uniforms: Assign linked uniforms of base template material\n        for (var name_3 in base.uniforms) {\n            var src = base.uniforms[name_3];\n            if (src.linked)\n                uniforms[name_3] = src;\n        }\n    }\n    // Applies uniforms defined for this new material\n    applyUniforms(material, object, properties, defines);\n    // Finally apply material properties\n    material.setValues(properties);\n    if (material.isCustomMaterial) {\n        for (var name_4 in uniforms) {\n            if (mapFlags[name_4] && uniforms[name_4].value)\n                material[name_4] = uniforms[name_4].value;\n        }\n    }\n    // Fix: since we use #ifdef false would be false positive\n    for (var name_5 in defines)\n        if (defines[name_5] === false)\n            delete defines[name_5];\n    // Fix: default for depth material packing\n    if (isDepthMaterial(source) && defines.DEPTH_PACKING === undefined)\n        defines.DEPTH_PACKING = THREE.RGBADepthPacking;\n    return material;\n}\nObject.assign(RawShaderMaterial.prototype, {\n    extend: extend,\n    uniform: uniform,\n    clone: clone,\n    link: link,\n    copy: copy,\n});\nObject.assign(ShaderMaterial.prototype, { extend: extend, uniform: uniform, clone: clone, link: link, copy: copy });\n// Polyfill to allow custom depth/distance materials as material variation\n// TODO: rather not typecast to `any` here - how to fix?\nif (ShaderMaterial.prototype.customDepthMaterial !== undefined) {\n    var MeshPolyfill = {\n        _customDepthMaterial: {\n            enumerable: true,\n            value: undefined,\n            writable: true,\n        },\n        _customDistanceMaterial: {\n            enumerable: true,\n            value: undefined,\n            writable: true,\n        },\n        customDepthMaterial: {\n            get: function () {\n                return (this._customDepthMaterial ||\n                    (this.material && this.material.customDepthMaterial\n                        ? this.material.customDepthMaterial\n                        : undefined));\n            },\n            set: function (value) {\n                this._customDepthMaterial = value;\n            },\n        },\n        customDistanceMaterial: {\n            get: function () {\n                return (this._customDistanceMaterial ||\n                    (this.material && this.material.customDistanceMaterial\n                        ? this.material.customDistanceMaterial\n                        : undefined));\n            },\n            set: function (value) {\n                this._customDistanceMaterial = value;\n            },\n        },\n    };\n    Object.defineProperties(THREE.Mesh.prototype, MeshPolyfill);\n    Object.defineProperties(THREE.SkinnedMesh.prototype, MeshPolyfill);\n}\n// A built-in materials compatible ShaderMaterial\nextend.CustomMaterial = function CustomMaterial(object) {\n    ShaderMaterial.call(this, object);\n    this.type = 'CustomMaterial';\n};\nObject.assign(extend.CustomMaterial.prototype, Material.prototype, ShaderMaterial.prototype, EventDispatcher.prototype, {\n    isShaderMaterial: true,\n    isCustomMaterial: true,\n    isMeshPhongMaterial: false,\n    isMeshDistanceMaterial: false,\n    isMeshMatcapMaterial: false,\n    isShadowMaterial: false,\n    isSpriteMaterial: false,\n    isRawShaderMaterial: false,\n    isPointsMaterial: false,\n    isMeshPhysicalMaterial: false,\n    isMeshStandardMaterial: false,\n    isMeshToonMaterial: false,\n    isMeshNormalMaterial: false,\n    isMeshLambertMaterial: false,\n    isMeshDepthMaterial: false,\n    isMeshBasicMaterial: false,\n    isLineDashedMaterial: false,\n    isLineBasicMaterial: false,\n    isMaterial: false,\n    isMeshFaceMaterial: false,\n    isMultiMaterial: false,\n    isPointCloudMaterial: false,\n    isParticleBasicMaterial: false,\n    isParticleSystemMaterial: false,\n    constructor: extend.CustomMaterial,\n    map: null,\n    aoMap: null,\n    envMap: null,\n    bumpMap: null,\n    normalMap: null,\n    lightMap: null,\n    emissiveMap: null,\n    specularMap: null,\n    roughnessMap: null,\n    metalnessMap: null,\n    alphaMap: null,\n    displacementMap: null,\n    clearcoatMap: null,\n    clearcoatRoughnessMap: null,\n    clearcoatNormalMap: null,\n    normalMapType: TangentSpaceNormalMap,\n    combine: MultiplyOperation,\n    clone: function (source) {\n        var clone = _clone.call(this);\n        if (this.map)\n            clone.map = this.map;\n        if (this.aoMap)\n            clone.aoMap = this.aoMap;\n        if (this.envMap)\n            clone.envMap = this.envMap;\n        if (this.bumpMap)\n            clone.bumpMap = this.bumpMap;\n        if (this.normalMap)\n            clone.normalMap = this.normalMap;\n        if (this.lightMap)\n            clone.lightMap = this.lightMap;\n        if (this.emissiveMap)\n            clone.emissiveMap = this.emissiveMap;\n        if (this.specularMap)\n            clone.specularMap = this.specularMap;\n        if (this.roughnessMap)\n            clone.roughnessMap = this.roughnessMap;\n        if (this.metalnessMap)\n            clone.metalnessMap = this.metalnessMap;\n        if (this.alphaMap)\n            clone.alphaMap = this.alphaMap;\n        if (this.displacementMap)\n            clone.displacementMap = this.displacementMap;\n        if (this.clearcoatMap)\n            clone.clearcoatMap = this.clearcoatMap;\n        if (this.clearcoatRoughnessMap)\n            clone.clearcoatRoughnessMap = this.clearcoatRoughnessMap;\n        if (this.clearcoatNormalMap)\n            clone.clearcoatNormalMap = this.clearcoatNormalMap;\n        clone.templates = this.templates;\n        return clone;\n    },\n});\nObject.defineProperties(extend.CustomMaterial.prototype, {\n    reflectivity: {\n        get: function () {\n            return this.uniforms.reflectivity\n                ? this.uniforms.reflectivity.value\n                : 0;\n        },\n        set: function (value) {\n            this.uniforms.reflectivity.value = value;\n        },\n    },\n    specular: {\n        get: function () {\n            if (this.uniforms.specular === undefined)\n                this.uniforms.specular = { value: new THREE.Color('white') };\n            return this.uniforms.specular.value;\n        },\n        set: function (value) {\n            if (this.uniforms.specular === undefined)\n                this.uniforms.specular = { value: value };\n            this.uniforms.specular.value = value;\n        },\n    },\n    shininess: {\n        get: function () {\n            return this.uniforms.shininess ? this.uniforms.shininess.value : 0;\n        },\n        set: function (value) {\n            if (this.uniforms.shininess === undefined)\n                this.uniforms.shininess = { value: value };\n            this.uniforms.shininess.value = value;\n        },\n    },\n});\n// Wrap ES6\n// if (!Object.isExtensible(THREE) || parseInt(THREE.REVISION) > 126) {\nvar CustomMaterial = /** @class */ (function (_super) {\n    __extends(CustomMaterial, _super);\n    function CustomMaterial(object) {\n        var _this = _super.call(this, object) || this;\n        _this.type = 'CustomMaterial';\n        return _this;\n    }\n    Object.defineProperty(CustomMaterial.prototype, \"specular\", {\n        get: function () {\n            if (this.uniforms.specular === undefined)\n                this.uniforms.specular = { value: new THREE.Color('white') };\n            return this.uniforms.specular.value;\n        },\n        set: function (value) {\n            if (this.uniforms.specular === undefined)\n                this.uniforms.specular = { value: value };\n            this.uniforms.specular.value = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CustomMaterial.prototype, \"shininess\", {\n        get: function () {\n            return this.uniforms.shininess ? this.uniforms.shininess.value : 0;\n        },\n        set: function (value) {\n            if (this.uniforms.shininess === undefined)\n                this.uniforms.shininess = { value: value };\n            this.uniforms.shininess.value = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CustomMaterial.prototype, \"reflectivity\", {\n        get: function () {\n            return this.uniforms.reflectivity ? this.uniforms.reflectivity.value : 0;\n        },\n        set: function (value) {\n            this.uniforms.reflectivity.value = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return CustomMaterial;\n}(ShaderMaterial));\nexports.CustomMaterial = CustomMaterial;\nObject.assign(CustomMaterial, extend.CustomMaterial);\nObject.assign(CustomMaterial.prototype, extend.CustomMaterial.prototype, {\n    copy: copy,\n    clone: clone,\n});\n// extend.CustomMaterial = CustomMaterial\n// }\n// Alias\nvar extendMaterial = extend;\nexports.extendMaterial = extendMaterial;\n// const CustomMaterial = extendMaterial.CustomMaterial\nvar sharedLightsUniforms;\n// Class name to internal lib names\nvar localsList = [\n    'bumpScale',\n    'roughness',\n    'metalness',\n    'shininess',\n    'envMapIntensity',\n    'opacity',\n    'dashSize',\n    'totalSize',\n];\nvar localsMapping = {\n    bumpScale: 'bumpScale',\n    roughness: 'roughness',\n    metalness: 'metalness',\n    shininess: 'shininess',\n    envMapIntensity: 'envMapIntensity',\n    opacity: 'opacity',\n    dashSize: 'dashSize',\n    totalSize: 'totalSize',\n};\nvar mapList = [\n    'map',\n    'aoMap',\n    'envMap',\n    'bumpMap',\n    'normalMap',\n    'lightMap',\n    'emissiveMap',\n    'specularMap',\n    'roughnessMap',\n    'metalnessMap',\n    'alphaMap',\n    'displacementMap',\n];\nvar mappings = {\n    MeshLambertMaterial: {\n        id: 'meshlambert',\n        name: 'lambert',\n    },\n    MeshBasicMaterial: {\n        id: 'meshbasic',\n        name: 'basic',\n    },\n    MeshStandardMaterial: {\n        id: 'meshphysical',\n        name: 'physical',\n    },\n    MeshPhongMaterial: {\n        id: 'meshphong',\n        name: 'phong',\n    },\n    MeshMatcapMaterial: {\n        id: 'meshmatcap',\n        name: 'matcap',\n    },\n    MeshToonMaterial: {\n        id: 'meshtoon',\n        name: 'toon',\n    },\n    PointsMaterial: {\n        id: 'points',\n        name: 'points',\n    },\n    LineDashedMaterial: {\n        id: 'dashed',\n        name: 'linedashed',\n    },\n    MeshDepthMaterial: {\n        id: 'depth',\n        name: 'depth',\n    },\n    MeshNormalMaterial: {\n        id: 'normal',\n        name: 'normal',\n    },\n    MeshDistanceMaterial: {\n        id: 'distanceRGBA',\n        name: 'distanceRGBA',\n    },\n    SpriteMaterial: {\n        id: 'sprite',\n        name: 'sprite',\n    },\n};\n// Aliases for shorter code hints\nvar aliases = {\n    lightsBegin: '?#include <lights_fragment_maps>',\n    lightsEnd: '?#include <aomap_fragment>',\n    colorBegin: '?#include <logdepthbuf_fragment>',\n    colorEnd: '?#include <tonemapping_fragment>',\n    transformBegin: '?#include <morphtarget_vertex>',\n    transformEnd: '?#include <project_vertex>',\n};\n// Converts properties to constant definition\nvar uniformFlags = {\n    alphaTest: {\n        as: 'ALPHATEST',\n        not: 0,\n    },\n};\n// Set of required uniforms ( which aren't null or zero )\nvar uniforms = {\n    opacity: { value: 1.0 },\n    specular: { value: new Color(0x111111) },\n};\nvar requiredUniforms = {\n    points: UniformsLibExtendable.points,\n    sprite: UniformsLibExtendable.sprite,\n    dashed: {\n        scale: { value: 1 },\n        dashSize: { value: 1 },\n        totalSize: { value: 2 },\n    },\n    normal: {\n        opacity: uniforms.opacity,\n    },\n    toon: {\n        specular: uniforms.specular,\n        shininess: { value: 30 },\n    },\n    standard: {\n        shininess: { value: 30 },\n        roughness: { value: 1.0 },\n        metalness: { value: 0.0 },\n        envMapIntensity: { value: 1 }, // temporary\n    },\n    physical: {\n        shininess: { value: 30 },\n        roughness: { value: 1.0 },\n        metalness: { value: 0.0 },\n        envMapIntensity: { value: 1 }, // temporary\n    },\n    phong: {\n        specular: uniforms.specular,\n        shininess: { value: 30 },\n    },\n    cube: {\n        opacity: uniforms.opacity,\n    },\n    distanceRGBA: {\n        nearDistance: { value: 1 },\n        farDistance: { value: 1000 },\n    },\n    shadow: {\n        opacity: uniforms.opacity,\n    },\n};\n// Constant definitions for which maps are used\nvar mapFlags = {\n    map: 'USE_MAP',\n    aoMap: 'USE_AOMAP',\n    envMap: 'USE_ENVMAP',\n    bumpMap: 'USE_BUMPMAP',\n    normalMap: 'USE_NORMALMAP',\n    lightMap: 'USE_LIGHTMAP',\n    emissiveMap: 'USE_EMISSIVEMAP',\n    specularMap: 'USE_SPECULARMAP',\n    roughnessMap: 'USE_ROUGHNESSMAP',\n    metalnessMap: 'USE_METALNESSMAP',\n    alphaMap: 'USE_ALPHAMAP',\n    displacementMap: 'USE_DISPLACEMENTMAP',\n};\nfunction useUniformPairs(instance, uniforms) {\n    // Only pairs with initial values other than null or zero needed\n    if (!instance)\n        return;\n    if (instance.envMap)\n        cloneUniforms(UniformsLibExtendable.envmap, uniforms);\n    if (instance.aoMap)\n        cloneUniforms(UniformsLibExtendable.aomap, uniforms);\n    if (instance.lightMap)\n        cloneUniforms(UniformsLibExtendable.lightmap, uniforms);\n    if (instance.bumpMap)\n        cloneUniforms(UniformsLibExtendable.bumpmap, uniforms);\n    if (instance.normalMap)\n        cloneUniforms(UniformsLibExtendable.normalmap, uniforms);\n    if (instance.displacementMap)\n        cloneUniforms(UniformsLibExtendable.displacementmap, uniforms);\n    if (instance.clearcoatNormalMap)\n        cloneUniforms(UniformsLibExtendable.clearcoatnormalmap, uniforms);\n}\nfunction useUniforms(name, object, uniforms) {\n    useUniformPairs(object.uniforms, uniforms);\n    if (object.common !== false)\n        cloneUniforms(UniformsLibExtendable.common, uniforms);\n    if (requiredUniforms[name] !== undefined)\n        cloneUniforms(requiredUniforms[name], uniforms);\n    var fog = object.fog ||\n        (object.material ? object.material.fog || object.material.useFog : null);\n    var lights = object.lights || (object.material ? object.material.lights : null);\n    if (fog)\n        cloneUniforms(UniformsLibExtendable.fog, uniforms);\n    if (lights) {\n        if (object.use) {\n            var use = object.use;\n            var shared = use.indexOf('sharedLights') > -1;\n            var shadows = use.indexOf('shadows') > -1;\n            if (use.indexOf('PointLight') > -1) {\n                cloneUniforms(UniformsLibExtendable.lights.pointLights, uniforms);\n                if (shadows) {\n                    cloneUniforms(UniformsLibExtendable.pointLightShadows, uniforms);\n                    cloneUniforms(UniformsLibExtendable.pointShadowMap, uniforms);\n                    cloneUniforms(UniformsLibExtendable.pointShadowMatrix, uniforms);\n                }\n            }\n            if (use.indexOf('SpotLight') > -1) {\n                cloneUniforms(UniformsLibExtendable.lights.spotLights, uniforms);\n                if (shadows) {\n                    cloneUniforms(UniformsLibExtendable.spotLightShadows, uniforms);\n                    cloneUniforms(UniformsLibExtendable.spotShadowMap, uniforms);\n                    cloneUniforms(UniformsLibExtendable.spotShadowMatrix, uniforms);\n                }\n            }\n            if (use.indexOf('DirectionalLight') > -1) {\n                cloneUniforms(UniformsLibExtendable.lights.directionalLights, uniforms);\n                if (shadows) {\n                    cloneUniforms(UniformsLibExtendable.directionalLightShadows, uniforms);\n                    cloneUniforms(UniformsLibExtendable.directionalShadowMap, uniforms);\n                    cloneUniforms(UniformsLibExtendable.directionalShadowMatrix, uniforms);\n                }\n            }\n            if (use.indexOf('LightProbe') > -1)\n                cloneUniforms(UniformsLibExtendable.lights.lightProbe, uniforms);\n            if (use.indexOf('AmbientLight') > -1)\n                cloneUniforms(UniformsLibExtendable.lights.ambientLightColor, uniforms);\n            if (use.indexOf('ReactAreaLight') > -1)\n                cloneUniforms(UniformsLibExtendable.lights.rectAreaLights, uniforms);\n            if (use.indexOf('HemisphereLight') > -1)\n                cloneUniforms(UniformsLibExtendable.lights.hemisphereLights, uniforms);\n        }\n        else {\n            cloneUniforms(sharedLightsUniforms, uniforms);\n        }\n    }\n    return uniforms;\n}\nfunction cloneUniform(src, dst) {\n    if (dst === void 0) { dst = {}; }\n    for (var key in src) {\n        var property = src[key];\n        if (property &&\n            (property.isColor ||\n                property.isMatrix3 ||\n                property.isMatrix4 ||\n                property.isVector2 ||\n                property.isVector3 ||\n                property.isVector4 ||\n                property.isTexture)) {\n            dst[key] = property.clone();\n        }\n        else if (Array.isArray(property)) {\n            dst[key] = property.slice();\n        }\n        else {\n            dst[key] = property;\n        }\n    }\n    return dst;\n}\nexports.cloneUniform = cloneUniform;\nfunction makeUniform(value) {\n    return value && value.value !== undefined ? value : { value: value };\n}\nfunction cloneUniforms(src, dst, notNull, share, mix, link) {\n    if (dst === void 0) { dst = {}; }\n    if (notNull === void 0) { notNull = false; }\n    if (share === void 0) { share = false; }\n    if (mix === void 0) { mix = false; }\n    if (link === void 0) { link = false; }\n    for (var u in src) {\n        var uniform_1 = src[u];\n        if (!uniform_1)\n            continue;\n        if (notNull) {\n            // Uniforms with null are skipped\n            if (uniform_1.value === null || uniform_1.value === 0)\n                continue;\n            // Their parameters then too\n        }\n        if (uniform_1.shared || (uniform_1.linked && link)) {\n            dst[u] = uniform_1;\n        }\n        else {\n            dst[u] = cloneUniform(uniform_1);\n            if (share === true)\n                dst[u].shared = true;\n            if (mix === true)\n                dst[u].mixed = true;\n        }\n    }\n    return dst;\n}\nexports.cloneUniforms = cloneUniforms;\nfunction applyPatches(chunk, map) {\n    for (var name in map) {\n        var value = map[name];\n        if (aliases[name] !== undefined)\n            name = aliases[name];\n        if (value instanceof Object) {\n            if (ShaderChunk[name] === undefined) {\n                console.error('ShaderMaterial.extend: ShaderChunk \"%s\" not found', name);\n            }\n            else {\n                chunk = chunk.replace('#include <' + name + '>', applyPatches(ShaderChunk[name], value));\n            }\n        }\n        else {\n            if (name[0] === '@') {\n                // Replace\n                var line = name.substr(1);\n                chunk = chunk.replace(line, value);\n            }\n            else if (name[0] === '?') {\n                // Insert before\n                var line = name.substr(1);\n                chunk = chunk.replace(line, value + '\\n' + line);\n            }\n            else {\n                // Insert after\n                if (!chunk) {\n                    console.error(\"THREE.patchShader: chunk not found '%s'\", name);\n                }\n                else {\n                    chunk = chunk.replace(name, name + '\\n' + value);\n                }\n            }\n        }\n    }\n    return chunk;\n}\nfunction applyConstants(name, uniform, defines, object, instance) {\n    // Uniforms that exist but are derived from the material instance internally\n    if (uniform && uniform.value && localsMapping[name] !== undefined)\n        instance[name] = uniform.value;\n    // Maps require USE_X constants\n    if (mapFlags[name] !== undefined &&\n        uniform &&\n        uniform.value !== undefined) {\n        // Expose uniform to be detected\n        instance[name] = uniform.value;\n    }\n    // Converts properties like alphaTest to their constant\n    var flag = uniformFlags[name];\n    if (flag !== undefined &&\n        (flag.not === undefined ||\n            // TODO: this was originally just `flag.not !== value`, but\n            // there's no `value` var. Is this the correct fix?\n            flag.not !== uniform.value))\n        defines[flag.as] = uniform.value;\n}\n// applyUniforms: Adds or overrides src uniforms to dst\nfunction applyUniforms(instance, src, dst, defines) {\n    if (!src.uniforms || !dst)\n        return;\n    for (var name in src.uniforms) {\n        if (!dst.uniforms[name])\n            dst.uniforms[name] = {};\n        // Accepts uniform objects and plain values\n        var uniform_2 = makeUniform(src.uniforms[name]);\n        // TODO: `applyConstants` returns void, so this check is always false.\n        // Is there something it should be doing?\n        // if (\n        //     defines &&\n        //     applyConstants(name, uniform, defines, src, instance) === false\n        // )\n        //     continue\n        dst.uniforms[name] = uniform_2;\n    }\n}\n// mixUniforms: Only adds new uniforms which are declared as mixed\nfunction mixUniforms(src, dst, defines) {\n    // Only mixed uniforms are passed to dst, only if they not exist\n    if (!src.uniforms)\n        return;\n    for (var name in src.uniforms) {\n        var uniform_3 = src.uniforms[name];\n        if (!uniform_3)\n            continue;\n        uniform_3 = makeUniform(uniform_3);\n        if (uniform_3.mixed && dst.uniforms[name] === undefined) {\n            dst.uniforms[name] = uniform_3.shared\n                ? uniform_3\n                : cloneUniform(uniform_3);\n            if (defines) {\n                // TODO: this was being called with just `(name, uniform, defines, src)`.\n                // is this the right fix?\n                applyConstants(name, uniform_3, defines, src, src);\n            }\n        }\n    }\n}\nfunction mapUniforms(name, uniforms, object) {\n    if (object.explicit === false) {\n        // Use all possible uniforms\n        return cloneUniforms(THREE.ShaderLib[name].uniforms, uniforms);\n    }\n    else {\n        // Only use declared and necessary\n        return useUniforms(name, object, uniforms); // cloneUniforms( THREE.ShaderLib[ name ].uniforms, uniforms, true );\n    }\n}\nfunction mapShader(name, type) {\n    var mapping = mappings[name];\n    return ShaderChunk[mapping.id + '_' + (type === 'vertex' ? 'vert' : 'frag')];\n}\nexports.mapShader = mapShader;\nfunction patchShader(shader, object, uniformsMixer, defines) {\n    // A shared header ( varyings, uniforms, functions etc )\n    if (uniformsMixer === void 0) { uniformsMixer = applyUniforms; }\n    if (defines === void 0) { defines = null; }\n    var header = (object.header || '') + '\\n';\n    var vertexShader = (object.vertexHeader || '') + '\\n' + shader.vertexShader;\n    var fragmentShader = (object.fragmentHeader || '') + '\\n' + shader.fragmentShader;\n    if (object.vertexEnd)\n        vertexShader = vertexShader.replace(/\\}(?=[^.]*$)/g, object.vertexEnd + '\\n}');\n    if (object.fragmentEnd)\n        fragmentShader = fragmentShader.replace(/\\}(?=[^.]*$)/g, object.fragmentEnd + '\\n}');\n    // Insert or replace lines (@ to replace)\n    if (object.vertex !== undefined)\n        vertexShader = applyPatches(vertexShader, object.vertex);\n    if (object.fragment !== undefined)\n        fragmentShader = applyPatches(fragmentShader, object.fragment);\n    shader.vertexShader = header + vertexShader;\n    shader.fragmentShader = header + fragmentShader;\n    if (uniformsMixer instanceof Function) {\n        // TODO: this was being called with just `(object, shader, defines)`\n        // args, which is missing an argument. Is this the best fix?\n        uniformsMixer(object, shader, defines, defines);\n    }\n    return shader;\n}\nexports.patchShader = patchShader;\nsharedLightsUniforms = cloneUniforms(UniformsLibExtendable.lights, {}, false, true);\n"},"sourceMaps":{"js":{"version":3,"file":"ExtendMaterial.js","sourceRoot":"","sources":["node_modules/three-extend-material/src/ExtendMaterial.ts"],"names":[],"mappings":"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","sourcesContent":["import * as THREE from 'three'\n\n// Author: Fyrestar https://mevedia.com (https://github.com/Fyrestar/THREE.extendMaterial)\n\nconst {\n    ShaderChunk,\n    UniformsLib,\n    Vector2,\n    Color,\n    EventDispatcher,\n\n    TangentSpaceNormalMap,\n    MultiplyOperation,\n\n    Material,\n    ShaderMaterial,\n    RawShaderMaterial,\n} = THREE\n\n// Utility functions\nfunction isShaderMaterial(target: any): target is THREE.ShaderMaterial {\n    return target && target.isShaderMaterial\n}\nfunction isDepthMaterial(target: any): target is THREE.MeshDepthMaterial {\n    return (\n        (target && target.isMeshDepthMaterial) ||\n        target === THREE.MeshDepthMaterial\n    )\n}\n\n// Fix missing pairs\n\nconst UniformsLibExtendable = UniformsLib as Record<string, any>\n\nUniformsLibExtendable.clearcoatnormalmap = {\n    clearcoatNormalScale: { value: new Vector2(1, 1) },\n}\n\n// Patch materials\n\nconst Materials = [\n    'MeshDistanceMaterial',\n    'MeshMatcapMaterial',\n    'ShadowMaterial',\n    'SpriteMaterial',\n    'RawShaderMaterial',\n    'ShaderMaterial',\n    'PointsMaterial',\n    'MeshPhysicalMaterial',\n    'MeshStandardMaterial',\n    'MeshPhongMaterial',\n    'MeshToonMaterial',\n    'MeshNormalMaterial',\n    'MeshLambertMaterial',\n    'MeshDepthMaterial',\n    'MeshBasicMaterial',\n    'LineDashedMaterial',\n    'LineBasicMaterial',\n    'Material',\n    'MeshFaceMaterial',\n    'MultiMaterial',\n    'PointCloudMaterial',\n    'ParticleBasicMaterial',\n    'ParticleSystemMaterial',\n]\n\nfor (let name of Materials) {\n    if (THREE[name] !== undefined) {\n        const prototype = THREE[name].prototype\n\n        // Type on prototype needed to identify when minified\n\n        prototype.type = name\n        prototype.customDepthMaterial = null\n        prototype.customDistanceMaterial = null\n        prototype.templates = []\n    }\n}\n\n// New material methods\n\nconst _clone = ShaderMaterial.prototype.clone\n\nfunction clone() {\n    const clone = _clone.call(this)\n\n    clone.templates = this.templates\n\n    return clone\n}\n\nfunction link(source) {\n    if (source && source.uniforms) {\n        for (let name in source.uniforms) {\n            if (source.uniforms[name].linked)\n                this.uniforms[name] = source.uniforms[name]\n        }\n    }\n\n    return this\n}\n\nfunction copy(source) {\n    Material.prototype.copy.call(this, source)\n\n    for (let name of mapList) {\n        if (source[name]) this[name] = source[name]\n    }\n\n    for (let name of localsList) {\n        if (source[name]) this[name] = source[name]\n    }\n\n    this.fragmentShader = source.fragmentShader\n    this.vertexShader = source.vertexShader\n\n    this.uniforms = cloneUniforms(source.uniforms)\n\n    this.defines = Object.assign({}, source.defines)\n\n    this.wireframe = source.wireframe\n    this.wireframeLinewidth = source.wireframeLinewidth\n\n    this.lights = source.lights\n    this.clipping = source.clipping\n\n    this.skinning = source.skinning\n\n    this.morphTargets = source.morphTargets\n    this.morphNormals = source.morphNormals\n\n    this.extensions = source.extensions\n\n    if (source.customDepthMaterial)\n        this.customDepthMaterial = source.customDepthMaterial.clone().link(this)\n\n    if (source.customDistanceMaterial)\n        this.customDistanceMaterial = source.customDistanceMaterial\n            .clone()\n            .link(this)\n\n    return this\n}\n\nfunction uniform(name) {\n    if (this.uniforms[name] === undefined) this.uniforms[name] = { value: null }\n\n    return this.uniforms[name]\n}\n\nfunction extend<T extends THREE.Material>(source: T, object) {\n    object = object || {}\n\n    // Extend from class or shader material\n\n    let uniforms = {},\n        vertexShader = '',\n        fragmentShader = ''\n\n    // Inherit from previous material templates chain\n\n    const base = object.template || object.extends\n    const MaterialClass =\n        object.class ||\n        (source.isMaterial && source.constructor ? source.constructor : null) ||\n        CustomMaterial\n\n    // New shader material\n\n    const material = new MaterialClass()\n    const properties = (object.material = object.material || {})\n    const defines = Object.assign({}, properties.defines)\n\n    // Template chain\n\n    material.templates = [object]\n\n    if ((source as any).templates instanceof Array)\n        material.templates = (source as any).templates.concat(\n            material.templates\n        )\n\n    let name\n\n    if (source instanceof Function) {\n        // Source is a constructor\n\n        name = source.prototype.type\n        const mapping = mappings[name]\n\n        if (mapping === undefined) {\n            console.error(\n                'THREE.extendMaterial: no mapping for material class \"%s\" found',\n                name\n            )\n\n            return material\n        }\n\n        properties.lights =\n            properties.lights === undefined ? true : properties.lights\n\n        uniforms = mapUniforms(mapping.name, uniforms, object) // Use only declared/necessary uniforms or all\n        vertexShader = ShaderChunk[mapping.id + '_vert']\n        fragmentShader = ShaderChunk[mapping.id + '_frag']\n    } else if (isShaderMaterial(source)) {\n        // Source is a ShaderMaterial\n\n        name = source.type\n\n        uniforms = cloneUniforms(source.uniforms, uniforms) // Use uniforms of previous material\n        vertexShader = source.vertexShader\n        fragmentShader = source.fragmentShader\n\n        material.copy(source, false)\n\n        if (source.defines) Object.assign(defines, source.defines)\n    } else {\n        // Source is a material instance\n\n        name = source.type\n        const mapping = mappings[name]\n\n        if (mapping === undefined) {\n            console.error(\n                'THREE.extendMaterial: no mapping for material class \"%s\" found',\n                name\n            )\n\n            return material\n        }\n\n        properties.lights =\n            properties.lights === undefined ? true : properties.lights\n\n        uniforms = mapUniforms(mapping.name, uniforms, object)\n        vertexShader = ShaderChunk[mapping.id + '_vert']\n        fragmentShader = ShaderChunk[mapping.id + '_frag']\n\n        // Built-in properties to uniforms ( if explicit not disabled, those being null will be skipped )\n\n        const defaults = THREE.ShaderLib[mapping.name].uniforms\n\n        for (let name in defaults)\n            if (\n                uniforms[name] === undefined &&\n                source[name] !== undefined &&\n                (source[name] !== null || object.explicit === false)\n            ) {\n                uniforms[name] = uniforms[name] || { value: null }\n                uniforms[name].value = source[name]\n            }\n    }\n\n    // ShaderMaterial in disguise ( currently not required )\n\n    //if ( material.isCustomMaterial )\n    //\tmaterial[ 'is' + name ] = true;\n\n    // Override constants\n\n    if (object.defines) Object.assign(defines, object.defines)\n\n    // A shared header ( varyings, uniforms, functions etc )\n\n    let header = (object.header || '') + '\\n'\n\n    // Insert or replace lines (@ to replace)\n\n    if (object.vertex !== undefined)\n        vertexShader = applyPatches(vertexShader, object.vertex)\n\n    if (object.fragment !== undefined)\n        fragmentShader = applyPatches(fragmentShader, object.fragment)\n\n    properties.defines = defines\n    properties.uniforms = uniforms\n    properties.vertexShader =\n        header + (object.vertexHeader || '') + '\\n' + vertexShader\n    properties.fragmentShader =\n        header + (object.fragmentHeader || '') + '\\n' + fragmentShader\n\n    if (object.vertexEnd)\n        properties.vertexShader = properties.vertexShader.replace(\n            /\\}(?=[^.]*$)/g,\n            object.vertexEnd + '\\n}'\n        )\n\n    if (object.fragmentEnd)\n        properties.fragmentShader = properties.fragmentShader.replace(\n            /\\}(?=[^.]*$)/g,\n            object.fragmentEnd + '\\n}'\n        )\n\n    // Uniforms override\n\n    if (object.override) {\n        for (let name in object.override) {\n            const src = object.override[name]\n            const dst = (uniforms[name] = uniforms[name] || { value: null })\n\n            for (let k in src) dst[k] = src[k]\n\n            // Expose mixed uniforms to template if not exposed yet ( material before might have been built-in )\n\n            if (dst.mixed) {\n                if (!object.uniforms) object.uniforms = {}\n\n                object.uniforms[name] = dst\n            }\n        }\n    }\n\n    // Apply base templates, uniforms that are required in a template must be flagged as mixed to get inherited\n\n    if (base && base.templates && base.templates.length) {\n        object.class = object.class || base.class\n\n        for (let template of base.templates)\n            patchShader(properties, template, mixUniforms, defines)\n\n        // Linked uniforms: Assign linked uniforms of base template material\n\n        for (let name in base.uniforms) {\n            const src = base.uniforms[name]\n\n            if (src.linked) uniforms[name] = src\n        }\n    }\n\n    // Applies uniforms defined for this new material\n\n    applyUniforms(material, object, properties, defines)\n\n    // Finally apply material properties\n\n    material.setValues(properties)\n\n    if (material.isCustomMaterial) {\n        for (let name in uniforms) {\n            if (mapFlags[name] && uniforms[name].value)\n                material[name] = uniforms[name].value\n        }\n    }\n\n    // Fix: since we use #ifdef false would be false positive\n\n    for (let name in defines) if (defines[name] === false) delete defines[name]\n\n    // Fix: default for depth material packing\n\n    if (isDepthMaterial(source) && defines.DEPTH_PACKING === undefined)\n        defines.DEPTH_PACKING = THREE.RGBADepthPacking\n\n    return material\n}\n\nObject.assign(RawShaderMaterial.prototype, {\n    extend,\n    uniform,\n    clone,\n    link,\n    copy,\n})\nObject.assign(ShaderMaterial.prototype, { extend, uniform, clone, link, copy })\n\n// Polyfill to allow custom depth/distance materials as material variation\n\n// TODO: rather not typecast to `any` here - how to fix?\nif ((ShaderMaterial.prototype as any).customDepthMaterial !== undefined) {\n    const MeshPolyfill = {\n        _customDepthMaterial: {\n            enumerable: true,\n            value: undefined,\n            writable: true,\n        },\n\n        _customDistanceMaterial: {\n            enumerable: true,\n            value: undefined,\n            writable: true,\n        },\n\n        customDepthMaterial: {\n            get: function () {\n                return (\n                    this._customDepthMaterial ||\n                    (this.material && this.material.customDepthMaterial\n                        ? this.material.customDepthMaterial\n                        : undefined)\n                )\n            },\n\n            set: function (value) {\n                this._customDepthMaterial = value\n            },\n        },\n\n        customDistanceMaterial: {\n            get: function () {\n                return (\n                    this._customDistanceMaterial ||\n                    (this.material && this.material.customDistanceMaterial\n                        ? this.material.customDistanceMaterial\n                        : undefined)\n                )\n            },\n\n            set: function (value) {\n                this._customDistanceMaterial = value\n            },\n        },\n    }\n\n    Object.defineProperties(THREE.Mesh.prototype, MeshPolyfill)\n    Object.defineProperties(THREE.SkinnedMesh.prototype, MeshPolyfill)\n}\n\n// A built-in materials compatible ShaderMaterial\n\nextend.CustomMaterial = function CustomMaterial(object) {\n    ShaderMaterial.call(this, object)\n\n    this.type = 'CustomMaterial'\n}\n\nObject.assign(\n    extend.CustomMaterial.prototype,\n    Material.prototype,\n    ShaderMaterial.prototype,\n    EventDispatcher.prototype,\n    {\n        isShaderMaterial: true,\n        isCustomMaterial: true,\n        isMeshPhongMaterial: false,\n        isMeshDistanceMaterial: false,\n        isMeshMatcapMaterial: false,\n        isShadowMaterial: false,\n        isSpriteMaterial: false,\n        isRawShaderMaterial: false,\n        isPointsMaterial: false,\n        isMeshPhysicalMaterial: false,\n        isMeshStandardMaterial: false,\n        isMeshToonMaterial: false,\n        isMeshNormalMaterial: false,\n        isMeshLambertMaterial: false,\n        isMeshDepthMaterial: false,\n        isMeshBasicMaterial: false,\n        isLineDashedMaterial: false,\n        isLineBasicMaterial: false,\n        isMaterial: false,\n        isMeshFaceMaterial: false,\n        isMultiMaterial: false,\n        isPointCloudMaterial: false,\n        isParticleBasicMaterial: false,\n        isParticleSystemMaterial: false,\n\n        constructor: extend.CustomMaterial,\n\n        map: null,\n        aoMap: null,\n        envMap: null,\n        bumpMap: null,\n        normalMap: null,\n        lightMap: null,\n        emissiveMap: null,\n        specularMap: null,\n        roughnessMap: null,\n        metalnessMap: null,\n        alphaMap: null,\n        displacementMap: null,\n        clearcoatMap: null,\n        clearcoatRoughnessMap: null,\n        clearcoatNormalMap: null,\n\n        normalMapType: TangentSpaceNormalMap,\n        combine: MultiplyOperation,\n\n        clone: function (source) {\n            const clone = _clone.call(this)\n\n            if (this.map) clone.map = this.map\n            if (this.aoMap) clone.aoMap = this.aoMap\n            if (this.envMap) clone.envMap = this.envMap\n            if (this.bumpMap) clone.bumpMap = this.bumpMap\n            if (this.normalMap) clone.normalMap = this.normalMap\n            if (this.lightMap) clone.lightMap = this.lightMap\n            if (this.emissiveMap) clone.emissiveMap = this.emissiveMap\n            if (this.specularMap) clone.specularMap = this.specularMap\n            if (this.roughnessMap) clone.roughnessMap = this.roughnessMap\n            if (this.metalnessMap) clone.metalnessMap = this.metalnessMap\n            if (this.alphaMap) clone.alphaMap = this.alphaMap\n            if (this.displacementMap)\n                clone.displacementMap = this.displacementMap\n            if (this.clearcoatMap) clone.clearcoatMap = this.clearcoatMap\n            if (this.clearcoatRoughnessMap)\n                clone.clearcoatRoughnessMap = this.clearcoatRoughnessMap\n            if (this.clearcoatNormalMap)\n                clone.clearcoatNormalMap = this.clearcoatNormalMap\n\n            clone.templates = this.templates\n\n            return clone\n        },\n    }\n)\n\nObject.defineProperties(extend.CustomMaterial.prototype, {\n    reflectivity: {\n        get: function () {\n            return this.uniforms.reflectivity\n                ? this.uniforms.reflectivity.value\n                : 0\n        },\n\n        set: function (value) {\n            this.uniforms.reflectivity.value = value\n        },\n    },\n\n    specular: {\n        get: function () {\n            if (this.uniforms.specular === undefined)\n                this.uniforms.specular = { value: new THREE.Color('white') }\n\n            return this.uniforms.specular.value\n        },\n\n        set: function (value) {\n            if (this.uniforms.specular === undefined)\n                this.uniforms.specular = { value }\n\n            this.uniforms.specular.value = value\n        },\n    },\n\n    shininess: {\n        get: function () {\n            return this.uniforms.shininess ? this.uniforms.shininess.value : 0\n        },\n\n        set: function (value) {\n            if (this.uniforms.shininess === undefined)\n                this.uniforms.shininess = { value }\n\n            this.uniforms.shininess.value = value\n        },\n    },\n})\n\n// Wrap ES6\n\n// if (!Object.isExtensible(THREE) || parseInt(THREE.REVISION) > 126) {\nclass CustomMaterial extends ShaderMaterial {\n    constructor(object) {\n        super(object)\n\n        this.type = 'CustomMaterial'\n    }\n\n    get specular() {\n        if (this.uniforms.specular === undefined)\n            this.uniforms.specular = { value: new THREE.Color('white') }\n\n        return this.uniforms.specular.value\n    }\n\n    set specular(value) {\n        if (this.uniforms.specular === undefined)\n            this.uniforms.specular = { value }\n\n        this.uniforms.specular.value = value\n    }\n\n    get shininess() {\n        return this.uniforms.shininess ? this.uniforms.shininess.value : 0\n    }\n\n    set shininess(value) {\n        if (this.uniforms.shininess === undefined)\n            this.uniforms.shininess = { value }\n\n        this.uniforms.shininess.value = value\n    }\n\n    get reflectivity() {\n        return this.uniforms.reflectivity ? this.uniforms.reflectivity.value : 0\n    }\n\n    set reflectivity(value) {\n        this.uniforms.reflectivity.value = value\n    }\n}\n\nObject.assign(CustomMaterial, extend.CustomMaterial)\nObject.assign(CustomMaterial.prototype, extend.CustomMaterial.prototype, {\n    copy,\n    clone,\n})\n\n// extend.CustomMaterial = CustomMaterial\n// }\n\n// Alias\n\nconst extendMaterial = extend\n// const CustomMaterial = extendMaterial.CustomMaterial\n\nlet sharedLightsUniforms\n\n// Class name to internal lib names\n\nconst localsList = [\n    'bumpScale',\n    'roughness',\n    'metalness',\n    'shininess',\n    'envMapIntensity',\n    'opacity',\n    'dashSize',\n    'totalSize',\n]\n\nconst localsMapping = {\n    bumpScale: 'bumpScale',\n    roughness: 'roughness',\n    metalness: 'metalness',\n    shininess: 'shininess',\n    envMapIntensity: 'envMapIntensity',\n    opacity: 'opacity',\n    dashSize: 'dashSize',\n    totalSize: 'totalSize',\n}\n\nconst mapList = [\n    'map',\n    'aoMap',\n    'envMap',\n    'bumpMap',\n    'normalMap',\n    'lightMap',\n    'emissiveMap',\n    'specularMap',\n    'roughnessMap',\n    'metalnessMap',\n    'alphaMap',\n    'displacementMap',\n]\n\nconst mappings = {\n    MeshLambertMaterial: {\n        id: 'meshlambert',\n        name: 'lambert',\n    },\n    MeshBasicMaterial: {\n        id: 'meshbasic',\n        name: 'basic',\n    },\n    MeshStandardMaterial: {\n        id: 'meshphysical',\n        name: 'physical',\n    },\n    MeshPhongMaterial: {\n        id: 'meshphong',\n        name: 'phong',\n    },\n    MeshMatcapMaterial: {\n        id: 'meshmatcap',\n        name: 'matcap',\n    },\n    MeshToonMaterial: {\n        id: 'meshtoon',\n        name: 'toon',\n    },\n    PointsMaterial: {\n        id: 'points',\n        name: 'points',\n    },\n    LineDashedMaterial: {\n        id: 'dashed',\n        name: 'linedashed',\n    },\n    MeshDepthMaterial: {\n        id: 'depth',\n        name: 'depth',\n    },\n    MeshNormalMaterial: {\n        id: 'normal',\n        name: 'normal',\n    },\n    MeshDistanceMaterial: {\n        id: 'distanceRGBA',\n        name: 'distanceRGBA',\n    },\n    SpriteMaterial: {\n        id: 'sprite',\n        name: 'sprite',\n    },\n}\n\n// Aliases for shorter code hints\n\nconst aliases = {\n    lightsBegin: '?#include <lights_fragment_maps>',\n    lightsEnd: '?#include <aomap_fragment>',\n    colorBegin: '?#include <logdepthbuf_fragment>',\n    colorEnd: '?#include <tonemapping_fragment>',\n    transformBegin: '?#include <morphtarget_vertex>',\n    transformEnd: '?#include <project_vertex>',\n}\n\n// Converts properties to constant definition\n\nconst uniformFlags = {\n    alphaTest: {\n        as: 'ALPHATEST',\n        not: 0,\n    },\n}\n\n// Set of required uniforms ( which aren't null or zero )\n\nconst uniforms = {\n    opacity: { value: 1.0 },\n    specular: { value: new Color(0x111111) },\n}\n\nconst requiredUniforms = {\n    points: UniformsLibExtendable.points,\n    sprite: UniformsLibExtendable.sprite,\n    dashed: {\n        scale: { value: 1 },\n        dashSize: { value: 1 },\n        totalSize: { value: 2 },\n    },\n    normal: {\n        opacity: uniforms.opacity,\n    },\n    toon: {\n        specular: uniforms.specular,\n        shininess: { value: 30 },\n    },\n    standard: {\n        shininess: { value: 30 },\n        roughness: { value: 1.0 },\n        metalness: { value: 0.0 },\n        envMapIntensity: { value: 1 }, // temporary\n    },\n    physical: {\n        shininess: { value: 30 },\n        roughness: { value: 1.0 },\n        metalness: { value: 0.0 },\n        envMapIntensity: { value: 1 }, // temporary\n    },\n    phong: {\n        specular: uniforms.specular,\n        shininess: { value: 30 },\n    },\n    cube: {\n        opacity: uniforms.opacity,\n    },\n    distanceRGBA: {\n        nearDistance: { value: 1 },\n        farDistance: { value: 1000 },\n    },\n    shadow: {\n        opacity: uniforms.opacity,\n    },\n}\n\n// Constant definitions for which maps are used\n\nconst mapFlags = {\n    map: 'USE_MAP',\n    aoMap: 'USE_AOMAP',\n    envMap: 'USE_ENVMAP',\n    bumpMap: 'USE_BUMPMAP',\n    normalMap: 'USE_NORMALMAP',\n    lightMap: 'USE_LIGHTMAP',\n    emissiveMap: 'USE_EMISSIVEMAP',\n    specularMap: 'USE_SPECULARMAP',\n    roughnessMap: 'USE_ROUGHNESSMAP',\n    metalnessMap: 'USE_METALNESSMAP',\n    alphaMap: 'USE_ALPHAMAP',\n    displacementMap: 'USE_DISPLACEMENTMAP',\n}\n\nfunction useUniformPairs(instance, uniforms) {\n    // Only pairs with initial values other than null or zero needed\n\n    if (!instance) return\n\n    if (instance.envMap) cloneUniforms(UniformsLibExtendable.envmap, uniforms)\n\n    if (instance.aoMap) cloneUniforms(UniformsLibExtendable.aomap, uniforms)\n\n    if (instance.lightMap)\n        cloneUniforms(UniformsLibExtendable.lightmap, uniforms)\n\n    if (instance.bumpMap) cloneUniforms(UniformsLibExtendable.bumpmap, uniforms)\n\n    if (instance.normalMap)\n        cloneUniforms(UniformsLibExtendable.normalmap, uniforms)\n\n    if (instance.displacementMap)\n        cloneUniforms(UniformsLibExtendable.displacementmap, uniforms)\n\n    if (instance.clearcoatNormalMap)\n        cloneUniforms(UniformsLibExtendable.clearcoatnormalmap, uniforms)\n}\n\nfunction useUniforms(name, object, uniforms) {\n    useUniformPairs(object.uniforms, uniforms)\n\n    if (object.common !== false)\n        cloneUniforms(UniformsLibExtendable.common, uniforms)\n\n    if (requiredUniforms[name] !== undefined)\n        cloneUniforms(requiredUniforms[name], uniforms)\n\n    const fog =\n        object.fog ||\n        (object.material ? object.material.fog || object.material.useFog : null)\n    const lights =\n        object.lights || (object.material ? object.material.lights : null)\n\n    if (fog) cloneUniforms(UniformsLibExtendable.fog, uniforms)\n\n    if (lights) {\n        if (object.use) {\n            const use = object.use\n            const shared = use.indexOf('sharedLights') > -1\n            const shadows = use.indexOf('shadows') > -1\n\n            if (use.indexOf('PointLight') > -1) {\n                cloneUniforms(\n                    UniformsLibExtendable.lights.pointLights,\n                    uniforms\n                )\n\n                if (shadows) {\n                    cloneUniforms(\n                        UniformsLibExtendable.pointLightShadows,\n                        uniforms\n                    )\n                    cloneUniforms(\n                        UniformsLibExtendable.pointShadowMap,\n                        uniforms\n                    )\n                    cloneUniforms(\n                        UniformsLibExtendable.pointShadowMatrix,\n                        uniforms\n                    )\n                }\n            }\n\n            if (use.indexOf('SpotLight') > -1) {\n                cloneUniforms(UniformsLibExtendable.lights.spotLights, uniforms)\n\n                if (shadows) {\n                    cloneUniforms(\n                        UniformsLibExtendable.spotLightShadows,\n                        uniforms\n                    )\n                    cloneUniforms(UniformsLibExtendable.spotShadowMap, uniforms)\n                    cloneUniforms(\n                        UniformsLibExtendable.spotShadowMatrix,\n                        uniforms\n                    )\n                }\n            }\n\n            if (use.indexOf('DirectionalLight') > -1) {\n                cloneUniforms(\n                    UniformsLibExtendable.lights.directionalLights,\n                    uniforms\n                )\n\n                if (shadows) {\n                    cloneUniforms(\n                        UniformsLibExtendable.directionalLightShadows,\n                        uniforms\n                    )\n                    cloneUniforms(\n                        UniformsLibExtendable.directionalShadowMap,\n                        uniforms\n                    )\n                    cloneUniforms(\n                        UniformsLibExtendable.directionalShadowMatrix,\n                        uniforms\n                    )\n                }\n            }\n\n            if (use.indexOf('LightProbe') > -1)\n                cloneUniforms(UniformsLibExtendable.lights.lightProbe, uniforms)\n\n            if (use.indexOf('AmbientLight') > -1)\n                cloneUniforms(\n                    UniformsLibExtendable.lights.ambientLightColor,\n                    uniforms\n                )\n\n            if (use.indexOf('ReactAreaLight') > -1)\n                cloneUniforms(\n                    UniformsLibExtendable.lights.rectAreaLights,\n                    uniforms\n                )\n\n            if (use.indexOf('HemisphereLight') > -1)\n                cloneUniforms(\n                    UniformsLibExtendable.lights.hemisphereLights,\n                    uniforms\n                )\n        } else {\n            cloneUniforms(sharedLightsUniforms, uniforms)\n        }\n    }\n\n    return uniforms\n}\n\nfunction cloneUniform(src, dst = {}) {\n    for (let key in src) {\n        const property = src[key]\n\n        if (\n            property &&\n            (property.isColor ||\n                property.isMatrix3 ||\n                property.isMatrix4 ||\n                property.isVector2 ||\n                property.isVector3 ||\n                property.isVector4 ||\n                property.isTexture)\n        ) {\n            dst[key] = property.clone()\n        } else if (Array.isArray(property)) {\n            dst[key] = property.slice()\n        } else {\n            dst[key] = property\n        }\n    }\n\n    return dst\n}\n\nfunction makeUniform(value) {\n    return value && value.value !== undefined ? value : { value: value }\n}\n\nfunction cloneUniforms(\n    src,\n    dst = {},\n    notNull = false,\n    share = false,\n    mix = false,\n    link = false\n) {\n    for (let u in src) {\n        const uniform = src[u]\n\n        if (!uniform) continue\n\n        if (notNull) {\n            // Uniforms with null are skipped\n\n            if (uniform.value === null || uniform.value === 0) continue\n\n            // Their parameters then too\n        }\n\n        if (uniform.shared || (uniform.linked && link)) {\n            dst[u] = uniform\n        } else {\n            dst[u] = cloneUniform(uniform)\n\n            if (share === true) dst[u].shared = true\n\n            if (mix === true) dst[u].mixed = true\n        }\n    }\n\n    return dst\n}\n\nfunction applyPatches(chunk, map) {\n    for (let name in map) {\n        const value = map[name]\n\n        if (aliases[name] !== undefined) name = aliases[name]\n\n        if (value instanceof Object) {\n            if (ShaderChunk[name] === undefined) {\n                console.error(\n                    'ShaderMaterial.extend: ShaderChunk \"%s\" not found',\n                    name\n                )\n            } else {\n                chunk = chunk.replace(\n                    '#include <' + name + '>',\n                    applyPatches(ShaderChunk[name], value)\n                )\n            }\n        } else {\n            if (name[0] === '@') {\n                // Replace\n\n                const line = name.substr(1)\n\n                chunk = chunk.replace(line, value)\n            } else if (name[0] === '?') {\n                // Insert before\n\n                const line = name.substr(1)\n\n                chunk = chunk.replace(line, value + '\\n' + line)\n            } else {\n                // Insert after\n\n                if (!chunk) {\n                    console.error(\n                        \"THREE.patchShader: chunk not found '%s'\",\n                        name\n                    )\n                } else {\n                    chunk = chunk.replace(name, name + '\\n' + value)\n                }\n            }\n        }\n    }\n\n    return chunk\n}\n\nfunction applyConstants(name, uniform, defines, object, instance) {\n    // Uniforms that exist but are derived from the material instance internally\n\n    if (uniform && uniform.value && localsMapping[name] !== undefined)\n        instance[name] = uniform.value\n\n    // Maps require USE_X constants\n\n    if (\n        mapFlags[name] !== undefined &&\n        uniform &&\n        uniform.value !== undefined\n    ) {\n        // Expose uniform to be detected\n\n        instance[name] = uniform.value\n    }\n\n    // Converts properties like alphaTest to their constant\n\n    const flag = uniformFlags[name]\n\n    if (\n        flag !== undefined &&\n        (flag.not === undefined ||\n            // TODO: this was originally just `flag.not !== value`, but\n            // there's no `value` var. Is this the correct fix?\n            flag.not !== uniform.value)\n    )\n        defines[flag.as] = uniform.value\n}\n\n// applyUniforms: Adds or overrides src uniforms to dst\n\nfunction applyUniforms(instance, src, dst, defines) {\n    if (!src.uniforms || !dst) return\n\n    for (let name in src.uniforms) {\n        if (!dst.uniforms[name]) dst.uniforms[name] = {}\n\n        // Accepts uniform objects and plain values\n\n        let uniform = makeUniform(src.uniforms[name])\n\n        // TODO: `applyConstants` returns void, so this check is always false.\n        // Is there something it should be doing?\n        // if (\n        //     defines &&\n        //     applyConstants(name, uniform, defines, src, instance) === false\n        // )\n        //     continue\n\n        dst.uniforms[name] = uniform\n    }\n}\n\n// mixUniforms: Only adds new uniforms which are declared as mixed\n\nfunction mixUniforms(src, dst, defines) {\n    // Only mixed uniforms are passed to dst, only if they not exist\n\n    if (!src.uniforms) return\n\n    for (let name in src.uniforms) {\n        let uniform = src.uniforms[name]\n\n        if (!uniform) continue\n\n        uniform = makeUniform(uniform)\n\n        if (uniform.mixed && dst.uniforms[name] === undefined) {\n            dst.uniforms[name] = uniform.shared\n                ? uniform\n                : cloneUniform(uniform)\n\n            if (defines) {\n                // TODO: this was being called with just `(name, uniform, defines, src)`.\n                // is this the right fix?\n                applyConstants(name, uniform, defines, src, src)\n            }\n        }\n    }\n}\n\nfunction mapUniforms(name, uniforms, object) {\n    if (object.explicit === false) {\n        // Use all possible uniforms\n\n        return cloneUniforms(THREE.ShaderLib[name].uniforms, uniforms)\n    } else {\n        // Only use declared and necessary\n\n        return useUniforms(name, object, uniforms) // cloneUniforms( THREE.ShaderLib[ name ].uniforms, uniforms, true );\n    }\n}\n\nfunction mapShader(name, type) {\n    const mapping = mappings[name]\n\n    return ShaderChunk[mapping.id + '_' + (type === 'vertex' ? 'vert' : 'frag')]\n}\n\nfunction patchShader(\n    shader,\n    object,\n    uniformsMixer = applyUniforms,\n    defines = null\n) {\n    // A shared header ( varyings, uniforms, functions etc )\n\n    let header = (object.header || '') + '\\n'\n    let vertexShader = (object.vertexHeader || '') + '\\n' + shader.vertexShader\n    let fragmentShader =\n        (object.fragmentHeader || '') + '\\n' + shader.fragmentShader\n\n    if (object.vertexEnd)\n        vertexShader = vertexShader.replace(\n            /\\}(?=[^.]*$)/g,\n            object.vertexEnd + '\\n}'\n        )\n\n    if (object.fragmentEnd)\n        fragmentShader = fragmentShader.replace(\n            /\\}(?=[^.]*$)/g,\n            object.fragmentEnd + '\\n}'\n        )\n\n    // Insert or replace lines (@ to replace)\n\n    if (object.vertex !== undefined)\n        vertexShader = applyPatches(vertexShader, object.vertex)\n\n    if (object.fragment !== undefined)\n        fragmentShader = applyPatches(fragmentShader, object.fragment)\n\n    shader.vertexShader = header + vertexShader\n    shader.fragmentShader = header + fragmentShader\n\n    if (uniformsMixer instanceof Function) {\n        // TODO: this was being called with just `(object, shader, defines)`\n        // args, which is missing an argument. Is this the best fix?\n        uniformsMixer(object, shader, defines, defines)\n    }\n\n    return shader\n}\n\nsharedLightsUniforms = cloneUniforms(\n    UniformsLibExtendable.lights,\n    {},\n    false,\n    true\n)\n\n// removing to keep things modular\n// if (Object.isExtensible(THREE)) {\n//     THREE.cloneUniforms = cloneUniforms\n//     THREE.cloneUniform = cloneUniform\n//     THREE.patchShader = patchShader\n//     THREE.mapShader = mapShader\n//     THREE.extendMaterial = extendMaterial\n//     THREE.CustomMaterial = CustomMaterial\n// }\n\nexport {\n    CustomMaterial,\n    patchShader,\n    extendMaterial,\n    cloneUniforms,\n    cloneUniform,\n    mapShader,\n}\n"]}},"error":null,"hash":"9adec66c81dba7c839404ccf01fbf694","cacheData":{"env":{}}}